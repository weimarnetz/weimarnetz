_olsr_ip_is_neigh ()
{
	local ip="$1"

	test -e /tmp/OLSR/isneigh_$ip
}

_olsr_build_tables ()				# building of /tmp/OLSR_TMP/ALL 		// is called every minute
{						#			   /LINKS
	local func="olsr_build_tables"		#			   /LINKS.sh
	local line				# and moving /tmp/OLSR_TMP/* -> /tmp/OLSR (which is used by all functions)
	local uptime_was_short			# also collecting routing_table
	local configfile="/var/etc/olsrd.conf"
	local max_errors=3

	mkdir -p /tmp/OLSR /tmp/OLSR_TMP

	[ -e "$configfile" ] || {
		_log do $func daemon info "config file not found, daemon was never started"
		return 0
	}

	while _olsr uptime is_short ; do {
		_log do $func daemon info "waiting till olsr-uptime is long enough"
		uptime_was_short="true"
		sleep 10
	} done

	while true; do {
		if _wget do "http://127.0.0.1:2006/all" >/tmp/OLSR_TMP/ALL ; then
			[ -e "/tmp/OLSR_TMP/ALL" ] && {
				[ "$( _file size "/tmp/OLSR_TMP/ALL" )" = "0" ] || {
					break
				}
			}

			[ $max_errors -eq 0 ] && return 1

			_log do $func daemon info "zero txtinfo.plugin-output, trying again"
		else
			if [ $max_errors -eq 0 ]; then
				if pidof olsrd >/dev/null ; then
					_olsr daemon restart "$func did not work, but daemon is up"
				else
					_olsr daemon start   "$func did not work, daemon is not up"
				fi

				return 1
			else
				_log do $func daemon info "wget-error trying again"
			fi
		fi

		max_errors=$(( $max_errors - 1 ))
		sleep "$( _math random_integer 1 5 )"
	} done

	ip route show table main >/tmp/OLSR_TMP/ROUTING_TABLE_MAIN	# fixme! update also when fetching neighbour table fails?

	while read line; do {
		case "$line" in
			"Table: Neighbors")			# fixme! safe all paragraphs? (All, Links, Neighbours, Topology, HNA, MID, Routes)
				break
			;;
			*)
				echo "$line"
			;;
		esac
	} done </tmp/OLSR_TMP/ALL >/tmp/OLSR_TMP/LINKS
								# COST of 'INFINITE' is converted to ''
	if _olsr version | fgrep -q 2009-10-27 ; then		# newstyle vs. old-style textinfo-plugin output

		sed -n 's/^\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9]\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)/LOCAL=\1;REMOTE=\2;LQ=\3;NLQ=\4;COST=\5;COUNT=\$(( \$COUNT + 1 ))/p' "/tmp/OLSR_TMP/LINKS" >"/tmp/OLSR_TMP/LINKS.sh"
	else
		sed -n '/0\.00/s/^\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*0\.00[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)/LOCAL=\1;REMOTE=\2;LQ=\3;NLQ=\4;COST=\5;COUNT=\$\(\( \$COUNT \+ 1 \)\)/p' "/tmp/OLSR_TMP/LINKS" >"/tmp/OLSR_TMP/LINKS.sh"
	fi

	mv /tmp/OLSR_TMP/* /tmp/OLSR

	did_we_ever_had_neighbours()
	{
		ls -1 /tmp/OLSR/isneigh_* >/dev/null 2>/dev/null
	}

	did_we_ever_had_neighbours && {
		[ $( _file size "/tmp/OLSR/LINKS.sh" ) -eq 0 ] && {
			_log do $func daemon alert "detected 0 neighbours"
			return 1
		}
	}

	[ "$uptime_was_short" = "true" ] && {
		/usr/sbin/cron.check_inet_gw_fff+
	}

	return 0
}

_olsr_remoteip2metric ()	# need OLSR_ROUTES
{
	local ip="$1"
	local file="/tmp/OLSR/ALL"	# fixme! make ROUTES

	ip="$( echo $ip | sed 's/\./\\\./g' )\/32"	# hiding dots for next regex and sed-safe append /32

	sed -n "/^$ip/{s/^$ip	[0-9\.]*	\([0-9]*\)	.*/\1/p;q}" "$file"
}

_olsr_daemon()
{
	local funcname="olsr_daemon"
	local ACTION="$1"
	local REASON="${2:-no_reason_given}"
	local LOGPRIO="alert"
	local LIST

	case "$REASON" in
		olsrd_restart_scheduler_controlled|plausi_check_failed|"becoming hna-master"*)
			LOGPRIO=info
		;;
	esac

	case "$ACTION" in
		start|stop|restart)

			case "$ACTION" in
				start|restart)
					_olsr uptime mark_restart
					echo >>/tmp/OLSR/restart_reasons "$( date ): $REASON"

					[ "$ACTION" = "start" ] && {
						pidof olsrd >/dev/null && {
							ACTION="restart"
						}
					}
				;;
			esac

			if [ "$ACTION" = "restart" ]; then
				LIST="stop start"
			else
				LIST="$ACTION"
			fi

			for ACTION in $LIST; do {
				_log do $funcname daemon $LOGPRIO "$ACTION: $REASON"
				/etc/init.d/*olsrd $ACTION | logger -s

				case "$ACTION" in
					stop)
						sleep 3
						pidof olsrd >/dev/null && {
							_watch hanging_command olsrd || {
								sleep 3
								_watch hanging_command olsrd
							}
						}
					;;
					start)
						_scheduler add "sleep 300"
						_scheduler add "_net refresh_dnshosts"
					;;
				esac
			} done
		;;
	esac
}

_olsr_neigh_list_macs ()
{
	echo "fixme!"	# webconfig needs this!
}

_olsr_version ()
{
	local VERSION

	case "$( _file hash /usr/sbin/olsrd )" in
		0e2e2a7075ab294e1f784bf1191e099a) VERSION="pre-0.6.0_2010-04-10_ff1.6.38" ;;
		0f5db811586d06a2eddd84e7d83f14e4) VERSION="pre-0.5.6-r7_2009-10-27_ff1.6.37" ;;
		64a7b006218164827df8c43e4a5574d4) VERSION="pre-0.5.6-r4_2009-01-02_ff1.6.36" ;;
		033811480fbd2cf9801a10f0112c5987) VERSION="pre-0.5.7-tip_2008-12-28_ff1.x.x" ;;
		*)
			if [ -e /etc/olsrd-release ]; then
				while read VERSION; do echo -n "$VERSION "; done </etc/olsrd-release
				VERSION="unknown build: $VERSION"
			else
				# exstract everything between *** [...] *** and strip spaces

				VERSION="$( olsrd -v 2>/dev/null | fgrep olsr.org | head -n1 | sed -n 's/^.*\*\*\*\(.*\)\*\*\*.*/\1/p' )"
				VERSION="$( echo "$VERSION" | sed 's/ //g' )"
			fi
		;;
	esac

	echo "$VERSION"
}

_olsr_uptime ()		# in seconds
{
	local KEYWORD="$1"		# string: "is_short", "mark_restart", "restarts_get", "restart_time" or <empty> = get
	local FUNC="olsr_uptime"
	local FILE_RESTART_TIME="/tmp/STATS_OLSR_RESTART_LAST"
	local FILE_RESTARTS="/tmp/STATS_OLSR_RESTARTS"
	local TIME_LAST_START TIME_NOW DIFF I

	TIME_NOW="$( _system uptime )"

	if [ -e $FILE_RESTART_TIME ]; then
		read TIME_LAST_START <$FILE_RESTART_TIME
	else
		echo "$TIME_NOW" >$FILE_RESTART_TIME
		TIME_LAST_START="$TIME_NOW"
	fi

	DIFF="$(( $TIME_NOW - ${TIME_LAST_START:-0} ))"

	case "$KEYWORD" in
		is_short)
			if [ $DIFF -lt 90 ]; then
				return 0
			else
				return 1
			fi
		;;
		mark_restart)
			echo "$TIME_NOW" >$FILE_RESTART_TIME
			
			read I 2>/dev/null <$FILE_RESTARTS
			echo $(( ${I:-0} + 1 )) >$FILE_RESTARTS
		;;
		restarts_get)
			read I 2>/dev/null <$FILE_RESTARTS

			[ ${I:-0} -gt 300 ] && {
				_log do $FUNC daemon alert "busybox bug: restarts_get: $I"
				I=0
			}

			echo ${I:-0}
		;;
		restart_time)
			DIFF="$(( $TIME_NOW - ${TIME_LAST_START:-0} ))"
			echo "$(( $( _system date unixtime ) - $DIFF ))"
		;;
		*)
			echo -n $DIFF
		;;
	esac
}

_olsr_gateways_get()		# OUT: list with each HNA4-0.0.0.0/0-announcing IP line by line
{
	local file="/tmp/OLSR/ALL"	# fixme! make ROUTES
	local line

	grep ^"0.0.0.0/0" "$file" | while read line; do set -- $line; test -n "$3" || echo $2; done
}

_olsr_neigh_random_get ()
{
	local FUNC="olsr_neigh_random_get"
	local FILE="/tmp/OLSR/LINKS.sh"

	local COST
	local COUNT=0
	local RANDOM

	while read LINE; do {
		eval $LINE
	} done <"$FILE"			# check REMOTE and COUNT

	if [ -n "$REMOTE" ]; then
		RANDOM="$( _math random_integer 1 $COUNT )"

		eval $( sed -n "${RANDOM}p" "$FILE" )

		echo "$REMOTE"
		return 0
	else
		_log do $FUNC daemon debug "no neighbour, no random neighour"
		return 1
	fi
}

_olsr_neigh_random_pair_from_mesh_evalable ()		# OUT: 'LOCAL={ip};REMOTE={ip};LQ=...;NLQ=...;COST=...'
{
	local FILE="/tmp/OLSR/ALL"		# use TOPOLOGY

	local LINES="$( sed -e '/./{H;$!d;}' -e "x;/^Table: Topology/!d;" $FILE | sed -n '$=' )"
	local RANDOM="$( _math random_integer 4 $LINES )"

	sed -e '/./{H;$!d;}' -e "x;/^Table: Topology/!d;" $FILE |
	 sed -n "${RANDOM}p" |
	  sed -n 's/^\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\).*/\LOCAL=\1\nREMOTE=\2\nLQ=\3\nNLQ=\4\nCOST=\5/p'
}

_olsr_node_evalable ()
{
	local NODE="$1"
	local FILE="/tmp/OLSR/ALL"		# use ROUTES
	
	sed -e '/./{H;$!d;}' -e "x;/^Table: Routes/!d;" $FILE |
	 grep ^"${NODE}/32" |
	  sed -n 's/^[0-9\.]*\/32[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9]*\)[^0-9]*\([0-9\.]*\).*/GATEWAY=\1\nMETRIC=\2\nCOST=\3/p'
}

_olsr_neigh_check_for_nonwifi ()
{
	local FUNC="olsr_check_if_any_nonwifi_neigh"
	local FILE="/tmp/OLSR/LINKS.sh"

	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$( _net dev_type $( _net iplocal2dev $LOCAL ) )"
		[ -n "$DEVTYPE" ] && {
			[ "$DEVTYPE" != "wifi" ] && {
				_log do $FUNC daemon debug "found nonwifi neigh: '$REMOTE'"
				return 0
			}
		}

	} done <"$FILE"

	_log do $FUNC daemon debug "found only wifi neighbours"
	return 1
}

_olsr_neigh_check_for_wifi ()
{
	local FUNC="olsr_check_for_wifi_neigh"
	local FILE="/tmp/OLSR/LINKS.sh"

	while read LINE; do {
		eval $LINE

		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ "$DEVTYPE" = "wifi" ] && {
			_log do $FUNC daemon debug "found wifi neigh: '$REMOTE'"
			return 0
		}

	} done <"$FILE"

	_log do $FUNC daemon debug "found only non-wifi neighbours"
	return 1
}

_olsr_neigh_nlq ()
{
	local FUNC="olsr_get_nlq"
	local FILE="/tmp/OLSR/LINKS.sh"
	local THIS_NEIGH="$1"
	local KEYWORD="$2"	# speedtest, fixme!
	local NLQ

	while read LINE; do {
		eval $LINE

		if [ "$REMOTE" = "$THIS_NEIGH" ]; then
			break
		else
			NLQ=
			LQ=
			COST=
		fi
	
	} done <"$FILE"

	if [ -z "$NLQ" ]; then
		return 1
	else
		_sanitizer include

		NLQ="$(  _sanitizer do "$NLQ"  numeric )"
		LQ="$(   _sanitizer do "$LQ"   numeric )"
		COST="$( _sanitizer do "$COST" numeric )"

		if [ -z "$KEYWORD" ]; then
			echo "${NLQ:-0}"
		else
			echo "NLQ=${NLQ:-0};LQ=${LQ:-0};COST=${COST:-0};"
		fi
	fi
}

_olsr_neigh_nlq_best_wifi ()
{
	local FUNC="olsr_best_wifi_nlq"
	local FILE="/tmp/OLSR/LINKS.sh"
	local NLQ_MAX=

	while read LINE; do {
		eval $LINE

		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ "$DEVTYPE" = "wifi" ] && {
			NLQ="$( echo ${NLQ:=0.000} | sed -ne 's/\.//' -e 's/^[0]*\([0-9]*\)/\1/p' )"		# 0.056 -> 56

			[ ${NLQ_MAX:=0} -lt ${NLQ:=0} ] && {
				NLQ_MAX="$NLQ"					# theoretical best value is 1.000 -> '1000'
				echo $REMOTE >/tmp/WIFI_OPTIMIZE_NEIGH		# for RRD-tool
			}
		}	

	} done <"$FILE"

	[ -z "$NLQ_MAX" ] && return 1

	echo $NLQ_MAX
}

_olsr_neigh_check_for_good_non_tunnel ()
{
	local FUNC="olsr_check_for_good_non_tunnel_neigh"
	local FILE="/tmp/OLSR/LINKS.sh"
	local BORDER="10"	# maximum suitable COST

	while read LINE; do {
		eval $LINE
		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ -n "$DEVTYPE" ] && {
			[ "$DEVTYPE" != "tunnel" ] && {
				[ -n "$COST" ] && {
					[ ${COST%[\.]*} -lt 10 ] && {
						_log do $FUNC daemon debug "found suitable neigh: '$LINE'"
						return 0
					}
				}
			}
		}

	} done <"$FILE"

	_log do $FUNC daemon debug "found nothing suitable"
	return 1 
}

_olsr_neighs ()
{
	local FUNC="olsr_neighs"
	local KEYWORD="${1:-neighbours}"			# ARG1 can be 'all' and defaults to 'neighbours'

	local TEMP="/tmp/olsr_output_$$.txt"
	local PLUGIN="olsrd_txtinfo"
	local FILE_CONFIG="/etc/olsrd.conf /var/etc/olsrd.conf"
	local URL="http://127.0.0.1:2006/$KEYWORD"

	grep -sq ^"LoadPlugin.*$PLUGIN\.so\." $FILE_CONFIG && {	

		_wget do "$URL" 5 >"$TEMP" || {

			rm "$TEMP"

			_olsr uptime is_short && {
				_log do $FUNC daemon info "waiting 60 sec for olsrd settle down"
				sleep 60
			}

			_wget do "$URL" >"$TEMP" && {
				echo -n "$TEMP"
				return 0
			}

			rm "$TEMP"

			if pidof olsrd >/dev/null ; then
				_log do $FUNC daemon crit "failed to fetch neighbour-table, but OLSRd seems to run?!"
			else
				_log do $FUNC daemon crit "failed to fetch neighbour-table, because OLSRd is'nt running"
			fi

			return 1
		}

		echo -n "$TEMP"
		return 0
	}

	_log do $FUNC daemon info "OLSRd is not configured to load plugin '$PLUGIN'" 
	return 1
}

_olsr_restarts_are_suspicious_often ()
{
	local func="olsr_restarts_are_suspicious_often"
	local daemon_restarts="$( _olsr uptime restarts_get )"
	local basecount="30"
	local percent border

	border="$(( $( _system uptime days ) * 3 ))"	# normally we hard restart 3 times a day:
	border="$(( $border + $basecount ))"		# 1 x cron.minutely + at 4 and 6 o'clock

	percent="$(( $daemon_restarts * 100 ))"
	percent="$(( $percent / $border ))"

	_log do $func daemon debug "percent from border: ${percent}% restarts: $daemon_restarts border: $border"	

	if [ $percent -gt 100 ]; then
		_log do $func daemon alert "[ERR] olsr restarts > normality (${percent}%: $daemon_restarts > $border)"

		if [ $percent -gt 300 ]; then	# seems to be a busybox-bug of v1.19.4
			return 0		# sometimes we see values of 35148643% (large restart count)
		else
			return 1
		fi
	else
		return 1
	fi
}

_olsr_neighs_extended_evalable ()
{
	local FILE="/tmp/OLSR/LINKS.sh"
	local VERBOSE="$2"

	local COUNT=0
	local LOCAL
	local REMOTE
	local LQ
	local NLQ
	local COST

	while read LINE; do {
		eval $LINE

		if [ -n "$VERBOSE" ]; then

			METRIC="$( _olsr remoteip2metric $REMOTE )"
			DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"

			echo "LOCAL=$LOCAL;REMOTE=$REMOTE;LQ=$LQ;NLQ=$NLQ;COST=$COST;DEVTYPE=$DEVTYPE;METRIC=$METRIC"
		else
			echo "LOCAL=$LOCAL;REMOTE=$REMOTE;LQ=$LQ;NLQ=$NLQ;COST=$COST;COUNT=$COUNT"
		fi

	} done <"$FILE"
}

_olsr_neighs_meshrdf_evalable ()		# e.g. ~ 422 : 10.63.42.1 : 10.63.167.65 : COST : 2.123 : 1.234 : 1.678 : 1 : 12 : 5.5 : n
{						# fixme! add _speedtest_stats()
	local FILE="/tmp/OLSR/LINKS.sh"		# 1+3+4+4+1+4+4+4+1+2+2 = 30 bytes / neigh
	local VERBOSE="$2"

	local COUNT=0
	local LOCAL REMOTE LQ NLQ COST
	local DEVTYPE METRIC
	local METHOD="COST"	# linkcost / etx / batadv / ...
	local txrate txthroughput mac minstrel efficiency system

	[ -d "/sys/kernel/debug/ieee80211/phy0/netdev:$WIFIDEV/stations" ] && {
		minstrel="true"
	}

	while read LINE; do {
		eval $LINE

		DEVTYPE="$(   _net devtype2symbol $( _net dev_type $( _net iplocal2dev $LOCAL ) ) )"
		METRIC="$( _olsr remoteip2metric $REMOTE )"
		REMOTE_ID="$( _ipsystem do $REMOTE )"

		[ "$minstrel" = "true" ] && {
			mac="$( _net ip2mac $REMOTE )"

			txrate=; txtroughput= ; efficiency=
			eval $( _wifi minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate "$mac" )
		}

		echo -n "${DEVTYPE}${REMOTE_ID}:${LOCAL}:${REMOTE}:${METHOD}:${LQ}:${NLQ}:${COST}:${METRIC}:${txrate:-0}:${txthroughput:-0}:${system:-0}"

	} done <"$FILE"
}

_olsr_neighs_humanreadable ()			# fixme! ToDo: latitude/longitude/distance + speed
{
	local FILE="/tmp/OLSR/LINKS.sh"
	local GATEWAY_IP="$( ip route list exact 0.0.0.0/0 | sed -n 's/^.* via \([0-9\.]*\) .*/\1/p;q' )"	# fixme! more abstraction, works
	local CONFIG_FILE
	local minstrel minstrel_stats file value txrate txthroughput

	[ "$( uci get wireless.radio0.type )" = "mac80211" ] && {
		[ -d "/sys/kernel/debug/ieee80211/phy0/netdev:$WIFIDEV/stations" ] && {
			minstrel="true"
		}
	}

	if [ -e /var/etc/olsrd.conf ]; then
		CONFIG_FILE="/var/etc/olsrd.conf"
	else
		CONFIG_FILE="/etc/olsrd.conf"
	fi

	local DNS METRIC LIST LINE DEVTYPE SPACER1 SPACER2 SPACER4 MAX1 MAX2 LQMULTI		# only for mesh-gateways
	local COUNT=0 LOCAL REMOTE LQ NLQ COST

	LIST="$( sed -n 's/^LOCAL=\([0-9\.]*\).*/\1/p' "$FILE" )"		# all local IP's
	MAX1="$( _sanitizer do "$LIST" list_get_longest_string )"
	LIST="$( sed -n 's/^.*;REMOTE=\([0-9\.]*\).*/\1/p' "$FILE" )"		# all remote IP's
	MAX2="$( _sanitizer do "$LIST" list_get_longest_string )"

	[ $( echo $LIST | wc -w ) -gt 9 ] && SPACER3=" "  	# numbering layout

	while read LINE; do {

	  	eval $LINE

		[ "$COST" = "INFINITE" ] && COST=

		DEVTYPE="$( _net devtype2symbol $( _net dev_type $(_net iplocal2dev $LOCAL ) ) )"
		DEVTYPE="${DEVTYPE}${DEVTYPE}"		# looks better

		MAC="$( _net ip2mac $REMOTE )"
		SPACER1="$( _sanitizer do "$MAX1 $LOCAL"  add_length_diff_with_spaces )"			# ip's should always have
		SPACER2="$( _sanitizer do "$MAX2 $REMOTE" add_length_diff_with_spaces )"			# the same length
		DNS="$( _net ip2dns $REMOTE )"
		METRIC="$( _olsr remoteip2metric $REMOTE )"
		[ $COUNT -gt 9 ] && unset SPACER3					# 9 -> ' 9'; 10 = 10

		LQMULTI="$( sed -n "/LinkQualityMult[^0-9]*${REMOTE}/{s/^.*LinkQualityMult[^0-9]*${REMOTE}[^0-9]*\([0-9\.]*\).*/[LQ x\1]/p;q}" $CONFIG_FILE )"

		SPACER4="  "
		[ "$REMOTE" = "$GATEWAY_IP" ] && SPACER4=">>"

		if [ "$minstrel" = "true" -a "$DEVTYPE" = "~~" ]; then

			[ -z "$MAC" ] && {
				arping -I $WIFIDEV -c 10 -q -f $REMOTE
				MAC="$( _net ip2mac $REMOTE )"
			}

			file="/sys/kernel/debug/ieee80211/phy0/netdev:$WIFIDEV/stations/$MAC"

			if [ -d "$file" ]; then

				minstrel_stats="sig/mbytes_TX,RX/rate/throughput:"

				value=
				read value 2>/dev/null <"$file/last_signal"
				minstrel_stats="$minstrel_stats ${value:-?}"

				value=
				read value 2>/dev/null <"$file/rx_bytes"
				minstrel_stats="$minstrel_stats/$( _math bytes2unit "$value" mbytes dotted )"

				value=
				read value 2>/dev/null <"$file/tx_bytes"
				minstrel_stats="$minstrel_stats/$( _math bytes2unit "$value" mbytes dotted )"

				txrate=; txthroughput=; efficiency=
				eval $( _wifi minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate $MAC )
				minstrel_stats="$minstrel_stats/$txrate/${txthroughput}@${efficiency}%  "
			else
				minstrel_stats="sig/mbytes_TX,RX/rate/throughput: ?  "
			fi
		else
			minstrel_stats=""
		fi

		echo "${SPACER3}${COUNT}:${SPACER4}${LOCAL}${SPACER1} ${DEVTYPE}${METRIC:=0}${DEVTYPE} ${REMOTE}${SPACER2}  LQ/NLQ/COST: ${LQ} / ${NLQ} / ${COST:=~    }  ${minstrel_stats}MAC+DNS: ${MAC:=??:??:??:??:??:??} '${DNS:=unknown}' ${LQMULTI}"

	} done <"$FILE"

	local OLSR_INGORE="$( uci get firewall.@ignoreolsr[0].ip )"
	[ -n "$OLSR_INGORE" ] && echo "ignored stations: $OLSR_INGORE"

	local hna4 route local_ip remote_ip
	for hna4 in $( _olsr_show_hna4_slaves ); do {
		route="$( ip -o route get $hna4 )"
		local_ip="$( echo "$route" | cut -d' ' -f8 )"
		remote_ip="$( echo "$route" | cut -d' ' -f3 )"

		COUNT=$(( ${COUNT:-0} + 1 ))
		echo "$COUNT:  $local_ip --1-- $remote_ip (HNA-slave $hna4)"
	} done
}

_olsr_show_hna4_slaves()
{
	local line slave_found cidr route local_ip remote_ip
	uci changes >"/tmp/uci_changes.$$"

	while read line; do {
		case "$line" in
			"olsrd."*)
				case "$line" in				# olsrd.cfg126b70=Hna4
					*"=Hna4")			# olsrd.cfg126b70.netaddr=10.10.12.0
						slave_found="true"	# olsrd.cfg126b70.netmask=255.255.255.192
					;;
					*".netaddr="*)
						slave_found="$( echo "$line" | cut -d'=' -f2 )"
					;;
					*".netmask="*)
						[ -n "$slave_found" ] && {
							cidr="$( echo "$line" | cut -d'=' -f2 )"
							cidr="$( _net mask2cidr "$cidr" )"

							echo "$slave_found/$cidr"
						}
					;;
					*)
						slave_found=
					;;
				esac
			;;
		esac
	} done <"/tmp/uci_changes.$$"

	rm "/tmp/uci_changes.$$"
}
